C51 COMPILER V9.60.0.0   LED                                                               05/11/2023 22:29:08 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE LED
OBJECT MODULE PLACED IN .\Objects\led.obj
COMPILER INVOKED BY: E:\keil5\keil5\C51\BIN\C51.EXE Driver\led.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\User;.\Config;.\Drive
                    -r;.\System) DEBUG OBJECTEXTEND PRINT(.\Listings\led.lst) OBJECT(.\Objects\led.obj)

line level    source

   1          #include "led.h"
   2          
   3          
   4          //æ•°ç ç®¡çœŸå€¼è¡¨
   5          unsigned char code Led_Number[] =
   6          {
   7                  0xc0, //0
   8                  0xf9, //1
   9                  0xa4, //2
  10                  0xb0, //3
  11                  0x99, //4
  12                  0x92, //5
  13                  0x82, //6
  14                  0xf8, //7
  15                  0x80, //8
  16                  0x90, //9
  17          };
  18          
  19          //æ•°ç ç®¡æ˜¾ç¤ºç¼“å­˜
  20          unsigned char Led_Buff[] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
  21          
  22          unsigned int Temp_Data_Max = 0; //æ¸©åº¦æ•°æ®æœ€å¤§å€¼
  23          unsigned int Temp_Data_Avg = 0; //æ¸©åº¦æ•°æ®å¹³å‡å€¼
  24          
  25          unsigned int Hum_Data_Max = 0;  //æ¹¿åº¦æ•°æ®æœ€å¤§å€¼
  26          unsigned int Hum_Data_Avg = 0;  //æ¹¿åº¦æ•°æ®å¹³å‡å€¼
  27          
  28          unsigned char Trip_Cnt = 0;             //è§¦å‘æ¬¡æ•°
  29          
  30          unsigned char Ds1302_Last_Trip_Time[3] = {0x00,0x00,0x00};      //ä¸Šä¸€æ¬¡è§¦å‘æ—¶é—´
  31          
  32          bit flag_Menu_Interrupt = 0;    //èœå•ä¸­æ–­æ ‡å¿—
  33          
  34          
  35          
  36          void SmgMenuMain()
  37          {
  38   1              if(flag_Menu_Interrupt == 0)    //å¦‚æœå½“å‰å…‰æ•ç”µé˜»æ²¡æœ‰è¢«è§¦å‘,åˆ™æ˜¾ç¤ºæ™®é€šç•Œé¢
  39   1              {
  40   2                      if(MenuModeSelect_S4 == 0)      //å¦‚æœèœå•æ¨¡å¼é€‰æ‹©ä¸º0ï¼Œæ˜¾ç¤ºæ—¶é’Ÿç•Œé¢
  41   2                      {
  42   3                              SmgMenuTimer(); //æ—¶é’Ÿç•Œé¢
  43   3                      }
  44   2                      else if(MenuModeSelect_S4 == 1) //å¦‚æœèœå•æ¨¡å¼é€‰æ‹©ä¸º1ï¼Œæ˜¾ç¤ºå›æ˜¾ç•Œé¢
  45   2                      {
  46   3                              SmgMenuBackup();        //å›æ˜¾ç•Œé¢
  47   3                      }
  48   2                      else if(MenuModeSelect_S4 == 2) //å¦‚æœèœå•æ¨¡å¼é€‰æ‹©ä¸º2ï¼Œæ˜¾ç¤ºå‚æ•°ç•Œé¢
  49   2                      {
  50   3                              SmgMenuParmData();      //å‚æ•°ç•Œé¢
  51   3                      }
  52   2              }
  53   1              else    //å¦‚æœå½“å‰å…‰æ•ç”µé˜»è¢«è§¦å‘,åˆ™è¿›å…¥æ¸©æ¹¿åº¦ç•Œé¢
  54   1              {
C51 COMPILER V9.60.0.0   LED                                                               05/11/2023 22:29:08 PAGE 2   

  55   2                      SmgMenuInterruptTempHum();      //æ¸©æ¹¿åº¦ç•Œé¢
  56   2              }
  57   1              
  58   1      }
  59          
  60          void LedDisplay()       //LEDæŒ‡ç¤ºç¯æ˜¾ç¤º
  61          {
  62   1              P0 = 0xFF;
  63   1              HC138Set(4);
  64   1              if(MenuModeSelect_S4 == 0)      //å¦‚æœèœå•æ¨¡å¼é€‰æ‹©ä¸º0,LED1äº®
  65   1              {
  66   2                      LED1 = 0;
  67   2              }
  68   1              else if(MenuModeSelect_S4 == 1) //å¦‚æœèœå•æ¨¡å¼é€‰æ‹©ä¸º1,LED2äº®
  69   1              {
  70   2                      LED2 = 0;
  71   2              }
  72   1              else if(MenuModeSelect_S4 == 2) //å¦‚æœèœå•æ¨¡å¼é€‰æ‹©ä¸º2,LED3äº®
  73   1              {
  74   2                      LED3 = 0;
  75   2              }
  76   1              
  77   1              if(flag_TempCmpParm == 1)       //å¦‚æœæ­¤æ¬¡æ¸©åº¦æ•°æ®è¶…è¿‡æ¸©åº¦å‚æ•°,LED4é—ªçƒ
  78   1              {
  79   2                      LED4 = flag_LED4_flash;
  80   2              }
  81   1              if(flag_HumData_Error == 1)     //å¦‚æœæ¹¿åº¦æ•°æ®é”™è¯¯,LED5äº®
  82   1              {
  83   2                      LED5 = 0;
  84   2              }
  85   1              if(Trip_Cnt >= 2)       //å¦‚æœè§¦å‘æ¬¡æ•°å¤§äºç­‰äº2
  86   1              {
  87   2                      if(flag_LED6_ON == 1)   //å¦‚æœæ­¤æ¬¡è§¦å‘çš„æ¸©åº¦å’Œæ¹¿åº¦æ•°æ®éƒ½å‡é«˜,åˆ™LED6äº®
  88   2                      {
  89   3                              LED6 = 0;
  90   3                      }
  91   2              }
  92   1              
  93   1              HC138Set(0);
  94   1              
  95   1      }
  96          
  97          
  98          void SmgMenuInterruptTempHum()  //æ¸©æ¹¿åº¦ç•Œé¢æ˜¾ç¤ºå†…å®¹å‡½æ•°
  99          {
 100   1              Led_Buff[0] = 0x86;     //æ˜¾ç¤ºç•Œé¢æ ‡å¿—,0x86æ˜¾ç¤ºå­—æ¯E
 101   1              
 102   1              Led_Buff[1] = 0xFF;     
 103   1              Led_Buff[2] = 0xFF;
 104   1              Led_Buff[3] = Led_Number[(Temp_Data_Trip/100)%10]; //æ˜¾ç¤ºæ¸©åº¦æ•°æ®çš„åä½        
 105   1              Led_Buff[4] = Led_Number[(Temp_Data_Trip/10)%10];       //æ˜¾ç¤ºæ¸©åº¦æ•°æ®çš„ä¸ªä½
 106   1              Led_Buff[5] = 0xBF;             //æ˜¾ç¤ºåˆ†éš”ç¬¦
 107   1              if(flag_HumData_Error == 0)             //å¦‚æœæ¹¿åº¦æ•°æ®æ²¡æœ‰é”™è¯¯,åˆ™æ˜¾ç¤ºæ¹¿åº¦æ•°æ®
 108   1              {
 109   2                      Led_Buff[6] = Led_Number[(Hum_Data_Trip/100)%10];       //æ˜¾ç¤ºæ¹¿åº¦æ•°æ®çš„åä½
 110   2                      Led_Buff[7] = Led_Number[(Hum_Data_Trip/10)%10];        //æ˜¾ç¤ºæ¹¿åº¦æ•°æ®çš„ä¸ªä½   
 111   2              }
 112   1              else    //å¦‚æœæ¹¿åº¦æ•°æ®é”™è¯¯,åˆ™æ˜¾ç¤ºå­—æ¯AA
 113   1              {
 114   2                      Led_Buff[6] = 0x88;
 115   2                      Led_Buff[7] = 0x88;             
 116   2              }
C51 COMPILER V9.60.0.0   LED                                                               05/11/2023 22:29:08 PAGE 3   

 117   1      }
 118          
 119          
 120          
 121          void SmgMenuParmData()  //æ¸©åº¦å‚æ•°ç•Œé¢
 122          {
 123   1              Led_Buff[0] = 0x8C;
 124   1              
 125   1              Led_Buff[1] = 0xFF;
 126   1              Led_Buff[2] = 0xFF;
 127   1              Led_Buff[3] = 0xFF;
 128   1              Led_Buff[4] = 0xFF;
 129   1              Led_Buff[5] = 0xFF;
 130   1              
 131   1              Led_Buff[6] = Led_Number[(Parm_Temp_Buf/100)%10];       //æ˜¾ç¤ºæ¸©åº¦å‚æ•°çš„åä½
 132   1              Led_Buff[7] = Led_Number[(Parm_Temp_Buf/10)%10];        //æ˜¾ç¤ºæ¸©åº¦å‚æ•°çš„ä¸ªä½
 133   1      }
 134          
 135          
 136          void SmgMenuBackup()    //å›æ˜¾ç•Œé¢é€‰æ‹©å‡½æ•°
 137          {
 138   1              if(BackupMenuChange_S5 == 0)    //å¦‚æœå›æ˜¾ç•Œé¢é€‰æ‹©ä¸º0,æ˜¾ç¤ºæ¸©åº¦å›æ˜¾ç•Œé¢
 139   1              {
 140   2                      SmgMenuBackupDataTempC();       //æ¸©åº¦å›æ˜¾ç•Œé¢
 141   2              }
 142   1              else if(BackupMenuChange_S5 == 1)       //å¦‚æœå›æ˜¾ç•Œé¢é€‰æ‹©ä¸º1,æ˜¾ç¤ºæ¹¿åº¦å›æ˜¾ç•Œé¢
 143   1              {
 144   2                      SmgMenuBackupDataHumidityH();   //æ¹¿åº¦å›æ˜¾ç•Œé¢
 145   2              }
 146   1              else if(BackupMenuChange_S5 == 2)       //å¦‚æœå›æ˜¾ç•Œé¢é€‰æ‹©ä¸º2,æ˜¾ç¤ºè§¦å‘æ¬¡æ•°å’Œæ—¶é—´å›æ˜¾ç•Œé¢
 147   1              {
 148   2                      SmgMenuBackupDataTimerAndTripF();       //è§¦å‘æ¬¡æ•°å’Œæ—¶é—´å›æ˜¾ç•Œé¢
 149   2              }
 150   1      }
 151          
 152          
 153          void SmgMenuBackupDataTimerAndTripF()   //è§¦å‘æ¬¡æ•°å’Œæ—¶é—´å›æ˜¾ç•Œé¢
 154          {
 155   1              Led_Buff[0] = 0x8E;
 156   1              Led_Buff[1] = Led_Number[(Trip_Cnt/10)%10];     //æ˜¾ç¤ºè§¦å‘æ¬¡æ•°çš„åä½
 157   1              Led_Buff[2] = Led_Number[(Trip_Cnt)%10];;               //æ˜¾ç¤ºè§¦å‘æ¬¡æ•°çš„ä¸ªä½
 158   1              
 159   1              Led_Buff[3] = Led_Number[Ds1302_Last_Trip_Time[2]>>4];          //æ˜¾ç¤ºæœ€åä¸€æ¬¡è§¦å‘æ—¶é—´ä¸­å°æ—¶çš„åä½
             -
 160   1              Led_Buff[4] = Led_Number[Ds1302_Last_Trip_Time[2]&0x0F];        //æ˜¾ç¤ºæœ€åä¸€æ¬¡è§¦å‘æ—¶é—´ä¸­å°æ—¶çš„ä¸ªä
             -½
 161   1              Led_Buff[5] = 0xBF;
 162   1              Led_Buff[6] = Led_Number[Ds1302_Last_Trip_Time[1]>>4];                  //æ˜¾ç¤ºæœ€åä¸€æ¬¡è§¦å‘æ—¶é—´ä¸­åˆ†é’Ÿçš„åä
             -½
 163   1              Led_Buff[7] = Led_Number[Ds1302_Last_Trip_Time[1]&0x0F];                //æ˜¾ç¤ºæœ€åä¸€æ¬¡è§¦å‘æ—¶é—´ä¸­åˆ†é’Ÿçš„ä¸ª
             -ä½
 164   1      }
 165          
 166          
 167          void SmgMenuBackupDataHumidityH()       //æ¹¿åº¦å›æ˜¾ç•Œé¢
 168          {
 169   1              Led_Buff[0] = 0x89;
 170   1              Led_Buff[1] = 0xFF;
 171   1              
 172   1              Led_Buff[2] = Led_Number[(Hum_Data_Max/100)%10];        //æ˜¾ç¤ºæ¹¿åº¦æœ€å¤§å€¼çš„åä½
 173   1              Led_Buff[3] = Led_Number[(Hum_Data_Max/10)%10];         //æ˜¾ç¤ºæ¹¿åº¦æœ€å¤§å€¼çš„ä¸ªä½
 174   1              
C51 COMPILER V9.60.0.0   LED                                                               05/11/2023 22:29:08 PAGE 4   

 175   1              Led_Buff[4] = 0xBF;
 176   1              
 177   1              Led_Buff[5] = Led_Number[(Hum_Data_Avg/100)%10];        //æ˜¾ç¤ºæ¹¿åº¦å¹³å‡å€¼çš„åä½
 178   1              Led_Buff[6] = Led_Number[(Hum_Data_Avg/10)%10] & 0x7F;  //æ˜¾ç¤ºæ¹¿åº¦å¹³å‡å€¼çš„ä¸ªä½
 179   1              Led_Buff[7] = Led_Number[(Hum_Data_Avg)%10];            //æ˜¾ç¤ºæ¹¿åº¦å¹³å‡å€¼å°æ•°ç‚¹åä¸€ä½
 180   1      }
 181          
 182          void SmgMenuBackupDataTempC()   //æ¸©åº¦å›æ˜¾ç•Œé¢
 183          {
 184   1              Led_Buff[0] = 0xC6;
 185   1              Led_Buff[1] = 0xFF;
 186   1              
 187   1              Led_Buff[2] = Led_Number[(Temp_Data_Max/100)%10];       //æ˜¾ç¤ºæ¸©åº¦æœ€å¤§å€¼çš„åä½
 188   1              Led_Buff[3] = Led_Number[(Temp_Data_Max/10)%10];        //æ˜¾ç¤ºæ¸©åº¦æœ€å¤§å€¼çš„ä¸ªä½
 189   1              
 190   1              Led_Buff[4] = 0xBF;     //æ˜¾ç¤ºåˆ†éš”ç¬¦
 191   1              
 192   1              Led_Buff[5] = Led_Number[(Temp_Data_Avg/100)%10];       //æ˜¾ç¤ºæ¸©åº¦å¹³å‡å€¼çš„åä½
 193   1              Led_Buff[6] = Led_Number[(Temp_Data_Avg/10)%10] & 0x7F; //æ˜¾ç¤ºæ¸©åº¦å¹³å‡å€¼çš„ä¸ªä½
 194   1              Led_Buff[7] = Led_Number[(Temp_Data_Avg)%10];           //æ˜¾ç¤ºæ¸©åº¦å¹³å‡å€¼å°æ•°ç‚¹åä¸€ä½
 195   1      }
 196          
 197          void SmgMenuTimer()     //æ—¶é—´æ˜¾ç¤ºç•Œé¢
 198          {
 199   1              Led_Buff[0] = Led_Number[Ds1302_Timer[2]>>4];
 200   1              Led_Buff[1] = Led_Number[Ds1302_Timer[2]&0x0F];
 201   1              Led_Buff[2] = 0xBF;
 202   1              Led_Buff[3] = Led_Number[Ds1302_Timer[1]>>4];
 203   1              Led_Buff[4] = Led_Number[Ds1302_Timer[1]&0x0F];
 204   1              Led_Buff[5] = 0xBF;
 205   1              Led_Buff[6] = Led_Number[Ds1302_Timer[0]>>4];
 206   1              Led_Buff[7] = Led_Number[Ds1302_Timer[0]&0x0F]; 
 207   1      }
 208          
 209          
 210          
 211          void SmgDisplay()       //æ•°ç ç®¡æ˜¾ç¤ºå‡½æ•°
 212          {
 213   1              static unsigned char i = 0;     //æ•°ç ç®¡ä½é€‰å˜é‡
 214   1              
 215   1              HC138Set(7);    //æ•°ç ç®¡æ®µé€‰
 216   1              P0 = 0xFF;              //æ¶ˆéš
 217   1              HC138Set(6);    //æ•°ç ç®¡ä½é€‰
 218   1              P0 = 0x01<<i;   //ä½é€‰,ä»å·¦åˆ°å³ä¾æ¬¡ç‚¹äº®æ•°ç ç®¡
 219   1              HC138Set(7);    //æ•°ç ç®¡æ®µé€‰
 220   1              P0 = 0xFF;              //æ¶ˆéš
 221   1              P0 = Led_Buff[i];       //æ®µé€‰,æ˜¾ç¤ºæ•°ç ç®¡çš„å€¼
 222   1              HC138Set(0);    //138è¯‘ç å™¨æ‚¬ç©º,é˜²æ­¢å¹²æ‰°åˆ°å…¶ä»–æ¨¡å—
 223   1              
 224   1              i++;    //æ•°ç ç®¡ä½é€‰å˜é‡è‡ªåŠ 
 225   1              i &= 0x07;              //æ•°ç ç®¡ä½é€‰å˜é‡é™åˆ¶åœ¨0~7ä¹‹é—´
 226   1      }
 227          
 228          
 229          
 230          
 231          
 232          
 233          
 234          
 235          
 236          
C51 COMPILER V9.60.0.0   LED                                                               05/11/2023 22:29:08 PAGE 5   

 237          
 238          
 239          
 240          
 241          
 242          
 243          
 244          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    868    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     21    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
